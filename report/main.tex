\documentclass[a4paper,titlepage,11pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{hyperref}

\begin{document}

\begin{titlepage}
  \begin{center}
    {\scshape \huge Graph Library \par}
    \vspace{1cm}

    {\scshape \LARGE Project \par}
    \vspace{1.5cm}

    {\scshape \Large Complex Network \par}
    \vspace{0.5cm}

    {\Large Alameda \par}
    \vfill

    {\itshape \Large Group 6 \par}
    \vfill

    \begin{tabular}{l l l}
      \includegraphics[width=15mm, height=15mm]{img/bernardo.jpeg} & Bernardo Casaleiro & 87827\\
      \includegraphics[width=15mm, height=15mm]{img/joao.jpeg} & João Godinho & 87830\\
    \end{tabular}
    \vfill

    {\large \today\par}
  \end{center}
\end{titlepage}

\section{Introduction}
As students coming from Computer Science we thought that the development of a small library for the third topic of the project would be interesting.
So we developed a simple library that generates a graph. This can be done randomly, using the random model or the Barabási-Albert model, or as '.gml' file.

After the graph is obtained you can use the available graph class attributes and methods as described below.

We chose \href{https://www.python.org}{Python} as our programming language for its simplicity and great comunity in this field.
For parsing the data sets we used the \href{https://networkx.github.io}{networkx} library, only using it to read the  '.gml' files and to receive the list of nodes and their edges.

In our implementation we assumed that the graphs are not directed.

\section{Library Structure}
In our library we tried to fight Python's speed problem. So we avoid any type of re-calculations.
In every method we first check if the graph has already that attribute set.
If it doesn't it's calculated and loaded into the respective atribute. Otherwise the method simply returns the attribute.

Because of that we advise the use of the \textit{get} methods for each variable.

\subsection*{Classes}
\begin{description}
\item [graph] Graph class where all the information of the graph is kept

\textit{ \textbf{Attributes} }
\begin{description}
\item [ nodes ] array:node \textbf{-} list of nodes
\item [ adjancy\_matrix ] array:array:int \textbf{-} adjacency matrix
\item [ clustering\_coefficient ] float \textbf{-} clustering coefficient
\item [ average\_path\_length ] float \textbf{-} average path length
\item [ max\_node\_degree ] int \textbf{-} maximum node degree in the graph
\item [ degree\_histogram ] array:int \textbf{-} degree histogram
\item [ degree\_distribution ] array:float \textbf{-} degree distribution
\item [ comulative\_degree\_distribution ] array:float \textbf{-} comulative degree distribution
\end{description}

\textit{ \textbf{Methods} }
\begin{description}
\item [get\_nodes] array:node ( ) - returns the list of nodes
\item [get\_adjacency\_matrix] array:array:int ( ) \textbf{-} returns the adjacency matrix
\item [get\_clustering\_coefficient] float ( ) \textbf{-} returns the clustering coefficient
\item [get\_average\_path\_length] float ( ) \textbf{-} returns the average path length
\item [calc\_node\_degrees] void ( ) \textbf{-} calculates the node degree for each node
\item [get\_max\_node\_degree] int ( ) \textbf{-} returns the maximum node degree in the graph
\item [get\_node\_degree\_histogram] array:int ( ) \textbf{-} returns the degree histogram
\item [get\_degree\_distribution] array:float ( ) \textbf{-} returns the degree distribution
\item [get\_cumulative\_degree\_distribution] array:float ( ) \textbf{-} returns the comulative degree distribution
\end{description}

\item [node] Node class where all the information of each node is kept

\textit{ \textbf{Atributes} }
\begin{description}
\item [edges] array:edge \textbf{-} list of the edges
\item [degree] int \textbf{-} degree of the node
\end{description}

\textit{ \textbf{Methods} }
\begin{description}
\item [get\_edges] array:edge ( ) \textbf{-} returns the list of edges
\item [get\_node\_degree] int ( ) \textbf{-} returns the node degree
\end{description}

\item [edge] Edge class where all the information of each edge is kept

\textit{ \textbf{Atributes} }
\begin{description}
\item [source] int \textbf{-} index of the source node
\item [target] int \textbf{-} index of the target node
\end{description}

\textit{ \textbf{Methods} }
\begin{description}
\item [get\_source] int ( ) \textbf{-} returns the source node
\item [get\_target] int ( ) \textbf{-} returns the target node
\end{description}

\end{description}

\subsection*{Methods}
\begin{description}
\item [read\_file] graph (string) \textbf{-} reads a proper formated gml file returning the graph object for that file
\item [generate\_random\_graph] graph (number of nodes, prob) \textbf{-} receives a number of nodes and the probability of
                                                            having a link between each other returning a random graph with that parameters
\item [generate\_barabasi\_albert\_graph] graph (number of initial nodes, number of links of each node, number of inserted nodes) \textbf{-} receives
                                                            the number of initial nodes, the number of links of each node and the number of inserted
                                                            nodes in the graph returning the graph object for that parameters using the Barabási-Albert Model.
\end{description}

\section{Results}
\subsection{Dataset}
\subsubsection{adjnoun.gml}
\textbf{Degree Distribution}

\textbf{Clustering Coefficient}

\textbf{Average Path Length}


\subsubsection{Properties}
\textbf{Degree Distribution}
\[
  P_k = \frac{N_k}{N} = \frac{1}{N}\sum_{i}{\delta(k_i-k)}
\]
\textbf{Clustering Coefficient}
\[
  C_i = \frac{\#\; edges\; among\; neigs}{max\; \# \; edges\; among \; neigs} = \frac{e_i}{k_i(k_i-1)/2}
\]

\[
  \langle C\rangle = \frac{1}{N}\sum_{i}{C_i}
\]
\textbf{Average Path Length}
\[
  \langle L\rangle = \frac{1}{N(N-1)}\sum_{ik}{L_{ik}}
\]

\subsection{Random Graph}


\subsubsection{Properties}
\textbf{Degree Distribution}
\[
  P(k) = {{N-1}\choose{k}} p^{k}(1-p)^{N-1-k}
\]
\textbf{Clustering Coefficient}
\[
  C_i = \frac{e_i}{k_i(k_i-1)/2} = p \frac{k_i(k_i-1)/2}{k_i(k_i-1)/2} = p = \frac{\langle k\rangle}{N}
\]
\textbf{Average Path Length}
\[
  APL = \langle L\rangle \simeq \frac{\ln{N}}{\ln{k}}
\]

\section{Reference}
\begin{description}
  \item[Python] \href{https://www.python.org}{www.python.org}
  \item[networkx] \href{https://networkx.github.io}{networkx.github.io}
  \item[Lecture Slides]
  \item[The Barabási-Albert Model] \href{http://barabasilab.neu.edu/networksciencebook/download/network_science_december_ch5_2013.pdf}{barabasilab.neu.edu/networksciencebook/download/network_science_december_ch5_2013.pdf}
\end{description}

\end{document}
